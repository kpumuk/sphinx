<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>
  File: README
  
    &mdash; Sphinx Client API Documentation
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!" + escape(window.location.href);
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'><h1>Sphinx Client API</h1>

<p><a href="http://travis-ci.org/kpumuk/sphinx"><img src="https://secure.travis-ci.org/kpumuk/sphinx.png" alt="Travis-CI build status"></a></p>

<p>This document gives an overview of what is Sphinx itself and how to use it
from your Ruby on Rails application. For more information about Sphinx and
its API documentation visit <a href="http://www.sphinxsearch.com">sphinxsearch.com</a>.</p>

<h2>Sphinx</h2>

<p>Sphinx is a standalone full-text search engine, meant to provide fast,
size-efficient and relevant fulltext search functions to other applications.
Sphinx was specially designed to integrate well with SQL databases and
scripting languages. Currently built-in data sources support fetching data
either via direct connection to MySQL, or from an XML pipe.</p>

<p>Simplest way to communicate with Sphinx is to use <code>searchd</code> â€”
a daemon to search through full text indexes from external software.</p>

<h2>Installation</h2>

<p>Add the &quot;sphinx&quot; gem to your <code>Gemfile</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>sphinx</span><span class='tstring_end'>'</span></span>
</code></pre>

<p>And run <code>bundle install</code> command.</p>

<h2>Documentation</h2>

<p>Complete Sphinx plugin documentation could be found on <a href="http://kpumuk.github.com/sphinx">GitHub Pages</a>.</p>

<p>Also you can find documentation on <a href="http://rdoc.info/projects/kpumuk/sphinx">rdoc.info</a>.</p>

<p>You can build the documentation locally by running:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rake'>rake</span> <span class='id identifier rubyid_yard'>yard</span>
</code></pre>

<p>Complete Sphinx API documentation could be found on <a href="http://www.sphinxsearch.com/docs/current.html">Sphinx Search Engine
site</a>.
This plugin is fully compatible with original PHP API implementation.</p>

<h2>Ruby naming conventions</h2>

<p>Sphinx Client API supports Ruby naming conventions, so every API
method name is in underscored, lowercase form:</p>

<pre class="code ruby"><code class="ruby">SetServer    -&gt; set_server
RunQueries   -&gt; run_queries
SetMatchMode -&gt; set_match_mode
</code></pre>

<p>Every method is aliased to a corresponding one from standard Sphinx
API, so you can use both <code>SetServer</code> and <code>set_server</code>
with no differrence.</p>

<p>There are three exceptions to this naming rule:</p>

<pre class="code ruby"><code class="ruby">GetLastError   -&gt; last_error
GetLastWarning -&gt; last_warning
IsConnectError -&gt; connect_error?
</code></pre>

<p>Of course, all of them are aliased to the original method names.</p>

<h2>Using multiple Sphinx servers</h2>

<p>Since we actively use this plugin in our Scribd development workflow,
there are several methods have been added to accommodate our needs.
You can find documentation on Ruby-specific methods in <a href="http://rdoc.info/projects/kpumuk/sphinx">documentation</a>.</p>

<p>First of all, we added support of multiple Sphinx servers to balance
load between them. Also it means that in case of any problems with one
of servers, library will try to fetch the results from another one.
Every consequence request will be executed on the next server in list
(round-robin technique).</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_set_servers'>set_servers</span><span class='lparen'>(</span><span class='lbracket'>[</span>
  <span class='lbrace'>{</span> <span class='symbol'>:host</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>browse01.local</span><span class='tstring_end'>'</span></span><span class='comma'>,</span> <span class='symbol'>:port</span> <span class='op'>=&gt;</span> <span class='int'>3312</span> <span class='rbrace'>}</span><span class='comma'>,</span>
  <span class='lbrace'>{</span> <span class='symbol'>:host</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>browse02.local</span><span class='tstring_end'>'</span></span><span class='comma'>,</span> <span class='symbol'>:port</span> <span class='op'>=&gt;</span> <span class='int'>3312</span> <span class='rbrace'>}</span><span class='comma'>,</span>
  <span class='lbrace'>{</span> <span class='symbol'>:host</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>browse03.local</span><span class='tstring_end'>'</span></span><span class='comma'>,</span> <span class='symbol'>:port</span> <span class='op'>=&gt;</span> <span class='int'>3312</span> <span class='rbrace'>}</span>
<span class='rbracket'>]</span><span class='rparen'>)</span>
</code></pre>

<p>By default library will try to fetch results from a single server, and
fail if it does not respond. To setup number of retries being performed,
you can use second (additional) parameter of the <code>set_connect_timeout</code>
and <code>set_request_timeout</code> methods:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_set_connect_timeout'>set_connect_timeout</span><span class='lparen'>(</span><span class='int'>1</span><span class='comma'>,</span> <span class='int'>3</span><span class='rparen'>)</span>
<span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_set_request_timeout'>set_request_timeout</span><span class='lparen'>(</span><span class='int'>1</span><span class='comma'>,</span> <span class='int'>3</span><span class='rparen'>)</span>
</code></pre>

<p>There is a big difference between these two methods. First will affect
only on requests experiencing problems with connection (socket error,
pipe error, etc), second will be used when request is broken somehow
(temporary searchd error, incomplete reply, etc). The workflow looks like
this:</p>

<ol>
<li>Increase retries number. If is less or equal to configured value,
try to connect to the next server. Otherwise, raise an error.</li>
<li>In case of connection problem go to 1.</li>
<li>Increase request retries number. If it less or equal to configured
value, try to perform request. Otherwise, raise an error.</li>
<li>In case of connection problem go to 1.</li>
<li>In case of request problem, go to 3.</li>
<li>Parse and return response.</li>
</ol>

<p>Withdrawals:</p>

<ol>
<li>Request could be performed <code>connect_retries</code> * <code>request_retries</code>
times. E.g., it could be tried <code>request_retries</code> times on each
of <code>connect_retries</code> servers (when you have 1 server configured,
but <code>connect_retries</code> is 5, library will try to connect to this
server 5 times).</li>
<li>Request could be tried to execute on each server <code>1..request_retries</code>
times. In case of connection problem, request will be moved to another
server immediately.</li>
</ol>

<p>Usually you will set <code>connect_retries</code> equal to servers number,
so you will be sure each failing request will be performed on all servers.
This means that if one of servers is live, but others are dead, you request
will be finally executed successfully.</p>

<h2>Sphinx constants</h2>

<p>Most Sphinx API methods expecting for special constants will be passed.
For example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_set_match_mode'>set_match_mode</span><span class='lparen'>(</span><span class='const'>Sphinx</span><span class='op'>::</span><span class='const'>SPH_MATCH_ANY</span><span class='rparen'>)</span>
</code></pre>

<p>Please note that these constants defined in a <code>Sphinx</code>
module. You can use symbols or strings instead of these awful
constants:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_set_match_mode'>set_match_mode</span><span class='lparen'>(</span><span class='symbol'>:any</span><span class='rparen'>)</span>
<span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_set_match_mode'>set_match_mode</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>any</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span>
</code></pre>

<h2>Setting query filters</h2>

<p>Every <code>set_</code> method returns <code>Sphinx::Client</code> object itself.
It means that you can chain filtering methods:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_results'>results</span> <span class='op'>=</span> <span class='const'>Sphinx</span><span class='op'>::</span><span class='const'>Client</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span>
            <span class='id identifier rubyid_set_match_mode'>set_match_mode</span><span class='lparen'>(</span><span class='symbol'>:any</span><span class='rparen'>)</span><span class='period'>.</span>
            <span class='id identifier rubyid_set_ranking_mode'>set_ranking_mode</span><span class='lparen'>(</span><span class='symbol'>:bm25</span><span class='rparen'>)</span><span class='period'>.</span>
            <span class='id identifier rubyid_set_id_range'>set_id_range</span><span class='lparen'>(</span><span class='int'>10</span><span class='comma'>,</span> <span class='int'>1000</span><span class='rparen'>)</span><span class='period'>.</span>
            <span class='id identifier rubyid_query'>query</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>test</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span>
</code></pre>

<p>There is a handful ability to set query parameters directly in <code>query</code>
call. If block does not accept any parameters, it will be eval&#39;ed inside
Sphinx::Client instance:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_results'>results</span> <span class='op'>=</span> <span class='const'>Sphinx</span><span class='op'>::</span><span class='const'>Client</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_query'>query</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>test</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_match_mode'>match_mode</span> <span class='symbol'>:any</span>
  <span class='id identifier rubyid_ranking_mode'>ranking_mode</span> <span class='symbol'>:bm25</span>
  <span class='id identifier rubyid_id_range'>id_range</span> <span class='int'>10</span><span class='comma'>,</span> <span class='int'>1000</span>
<span class='kw'>end</span>
</code></pre>

<p>As you can see, in this case you can omit the <code>set_</code> prefix for
this methods. If block accepts a parameter, sphinx instance will be
passed into the block. In this case you should you full method names
including the <code>set_</code> prefix:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_results'>results</span> <span class='op'>=</span> <span class='const'>Sphinx</span><span class='op'>::</span><span class='const'>Client</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_query'>query</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>test</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_sphinx'>sphinx</span><span class='op'>|</span>
  <span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_set_match_mode'>set_match_mode</span> <span class='symbol'>:any</span>
  <span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_set_ranking_mode'>set_ranking_mode</span> <span class='symbol'>:bm25</span>
  <span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_set_id_range'>set_id_range</span> <span class='int'>10</span><span class='comma'>,</span> <span class='int'>1000</span>
<span class='kw'>end</span>
</code></pre>

<h2>Example</h2>

<p>This simple example illustrates base connection establishing,
search results retrieving, and excerpts building. Please note
how does it perform database select using ActiveRecord to
save the order of records established by Sphinx.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_sphinx'>sphinx</span> <span class='op'>=</span> <span class='const'>Sphinx</span><span class='op'>::</span><span class='const'>Client</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_query'>query</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>test</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_ids'>ids</span> <span class='op'>=</span> <span class='id identifier rubyid_result'>result</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>matches</span><span class='tstring_end'>'</span></span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_match'>match</span><span class='op'>|</span> <span class='id identifier rubyid_match'>match</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>id</span><span class='tstring_end'>'</span></span><span class='rbracket'>]</span> <span class='rbrace'>}</span>
<span class='id identifier rubyid_posts'>posts</span> <span class='op'>=</span> <span class='const'>Post</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span> <span class='symbol'>:conditions</span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span> <span class='symbol'>:id</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_ids'>ids</span> <span class='rbrace'>}</span><span class='comma'>,</span>
                 <span class='symbol'>:order</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>FIELD(id,</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_ids'>ids</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>,</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span><span class='rbrace'>}</span><span class='tstring_content'>)</span><span class='tstring_end'>&quot;</span></span>

<span class='id identifier rubyid_docs'>docs</span> <span class='op'>=</span> <span class='id identifier rubyid_posts'>posts</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:body</span><span class='rparen'>)</span>
<span class='id identifier rubyid_excerpts'>excerpts</span> <span class='op'>=</span> <span class='id identifier rubyid_sphinx'>sphinx</span><span class='period'>.</span><span class='id identifier rubyid_build_excerpts'>build_excerpts</span><span class='lparen'>(</span><span class='id identifier rubyid_docs'>docs</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>index</span><span class='tstring_end'>'</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>test</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span>
</code></pre>

<h2>Logging</h2>

<p>You can ask Sphinx client API to log it&#39;s activity to some log. In
order to do that you can pass a logger object into the <code>Sphinx::Client</code>
constructor:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>logger</span><span class='tstring_end'>'</span></span>
<span class='const'>Sphinx</span><span class='op'>::</span><span class='const'>Client</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='const'>Logger</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='const'>STDOUT</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_query'>query</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>test</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span>
</code></pre>

<p>Logger object should respond to methods :debug, :info, and :warn, and
accept blocks (this is what standard Ruby <code>Logger</code> class does).
Here is what you will see in your log:</p>

<ul>
<li><code>DEBUG</code> -- <code>query</code>, <code>add_query</code>, <code>run_queries</code>
method calls with configured filters.</li>
<li><code>INFO</code> -- initialization with Sphinx version, servers change,
attempts to re-connect, and all attempts to do an API call with server
where request being performed.</li>
<li><code>WARN</code> -- various connection and socket errors.</li>
</ul>

<h2>Support</h2>

<p>You can find source code for this library on <a href="http://github.com/kpumuk/sphinx">GitHub</a>.</p>

<p>To suggest a feature or report a bug use <a href="http://github.com/kpumuk/sphinx/issues">GitHub Issues</a></p>

<h2>Credits</h2>

<ul>
<li><a href="https://github.com/kpumuk">Dmytro Shteflyuk</a> (author)</li>
<li><a href="http://sphinxsearch.com">Andrew Aksyonoff</a> (Sphinx core developer)</li>
</ul>

<p>Special thanks to <a href="https://github.com/kovyrin">Alexey Kovyrin</a></p>

<p>Special thanks to <a href="https://github.com/mperham">Mike Perham</a> for his awesome
memcache-client gem, where latest Sphinx gem got new sockets handling from.</p>

<h2>License</h2>

<p>This library is distributed under the terms of the Ruby license.
You can freely distribute/modify this library.</p>
</div></div>

    <div id="footer">
  Generated on Thu Mar 14 12:34:39 2013 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.5.2 (ruby-1.9.3).
</div>

  </body>
</html>